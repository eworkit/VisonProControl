using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Text;
using System.Windows.Forms;
using System.Collections;
using System.Threading;
using System.IO;

using Cognex.VisionPro;
using Cognex.VisionPro.QuickBuild;
using Cognex.VisionPro.QuickBuild.Implementation.Internal;
using Cognex.VisionPro.ToolGroup;
using Cognex.VisionPro.Implementation;
using Cognex.VisionPro.ToolGroup;
using Cognex.VisionPro.ResultsAnalysis;
using Cognex.VisionPro.ToolBlock;
using Automation.BDaq;
using log4net;
using Sunny.UI.Win32;
using static System.Net.WebRequestMethods;
using File = System.IO.File;
using System.Diagnostics;
using System.Linq;
using System.Runtime.Remoting.Metadata.W3cXsd2001;
using System.Device.Gpio;
using Utilities.UI.ExMethod;
using Utilities;
using Utilities.ExMethod;

namespace VisionControl
{

    public enum RunState { Stopped, RunningContinuous, RunningOnce, RunningLive };

    public partial class VisionUC : Sunny.UI.UIUserControl
    {
        const string runJobCmd = "CCD ";
        //==20220718
        private CogToolGroup myTG = new CogToolGroup();
        //  private CogToolBlock MyToolBlock = new CogToolBlock();
        //==20220718

        private readonly object _jobsLock = new object();
        public CogAcqInfo acqInfo = new CogAcqInfo();
        private CogAcqFifoTool AcqFifoTool = new CogAcqFifoTool();
        CheckBox checkBox_LiveDisplay = new CheckBox();
        CogJobResultHistoryCollectionEdit cogJobResultHistoryCollectionEdit1 = new CogJobResultHistoryCollectionEdit();
        ToolTip toolTip = new ToolTip();
        #region Private data
        private const int MaximumPeriodMs = 500;
        private const int MinimumPeriodMs = 50;
        private System.Threading.Timer mMaximumGuiPeriodTimer;
        private System.Threading.Timer mMinimumGuiPeriodTimer;
        private bool mMinimumGuiUpdateNeeded = false;
        private bool mHaveUnpaintedResults = false;

        // Queue lengths, for the "all results" and "failing results" queues.
        // To disable the "failing results" queue, set its length to 1.  Queues must always be a least 1 element
        // in length, to hold the current result.
        private const int AllQueueLength = 16;
        private const int FailureQueueLength = 16;

        private PasswordFile mCurrentPasswordFile;
        private string mLoadedVppFilename;

        private OptionsFile mCurrentOptionsFile;

        private CogJobManager mJM = null;
        private bool mAttached = false;
        private int mSelectedJob = 0;
        public AccessLevel CurrentAccessLevel
        {
            get
            {
                return mCurrentAccessLevel;
            }
            set
            {
                mCurrentAccessLevel = value;
                UpdateControlsEnabled(true);
            }
        }
        private CogJobResultHistoryCollection mHistoryCollection = new CogJobResultHistoryCollection();
        bool _IsAllRun = false;
        bool _IsPreview = false;
        private RunState mCurrentRunState = RunState.Stopped;
        private JobData[] mJobData = null;
        private bool mInitError = false;
        //private bool mStarted = false;
        private bool mIsClosing = false;

        // resource support for localization
        private Hashtable mResultTextHash;
        private string jobError;
        Stopwatch stopWatch = new Stopwatch();
        ILog log = LogManager.GetLogger(typeof(VisionUC));
        #endregion

        #region Public interface
        /// <summary>
        /// Read-only property to retrieve the CogJobManager.
        /// </summary>
        public CogJobManager JobManager
        {
            get { return mJM; }
        }

        /// <summary>
        /// Read-only property to retrieve the application name.
        /// </summary>
        public string ApplicationName
        {
            get { return mApplicationName; }
        }

        /// <summary>
        /// Read-only property to retrieve the filename of the loaded .vpp file.
        /// </summary>
        public string LoadedVppFilename
        {
            get { return mLoadedVppFilename; }
        }

        /// <summary>
        /// Read-only property indicating if passwords are in use by the generated code or not.
        /// </summary>
        public bool UsingPasswords
        {
            get { return mUsePasswords; }
        }

        /// <summary>
        /// If passwords are in use, returns the current password file.
        /// </summary>
        public PasswordFile CurrentPasswordFile
        {
            get { return mCurrentPasswordFile; }
        }

        /// <summary>
        /// Read-only property indicating the time at which this code was generated by the wizard.
        /// </summary>
        public static DateTime GenerationDateTime
        {
            get { return mGenerationDateTime; }
        }

        /// <summary>
        /// Read-only property indicating the what version of the wizard was used to generate this code.
        /// </summary>
        public static string GeneratedByVersion
        {
            get { return mGeneratedByVersion; }
        }

        public bool AutoRunMode
        {
            get
            {
                return autoRunMode;
            }
            set
            {
                if (autoRunMode != value)
                {
                    autoRunMode = value;
                    AutoRunModeChanged?.Invoke(value);
                }
            }
        }
        public RunState CurrentRunState => mCurrentRunState;
        public int SelectedTab => tabControl_JobTabs.SelectedIndex;

        public bool InitError => mInitError;
        public event Action<bool> AutoRunModeChanged;
        public event Action<string> ProjectOpened;
        /// <summary>
        /// Event fired for every user result produced by a job in the QuickBuild application (.vpp
        /// file).  The event is fired by the job thread itself, so any subscribers must handle this
        /// event in a timely manner.
        /// </summary>
        public event VisionControlUserResultAvailableEventHandler VisionControlUserResultAvailable = null;

        /// <summary>
        /// Clears all results from the result history queues of all jobs.
        /// </summary>
        public void ClearHistoryQueues(object sender, EventArgs e)
        {
            if (this.InvokeRequired)
            {
                // Call this same function on the GUI thread.
                Invoke(new EventHandler(ClearHistoryQueues), new object[] { sender, e });
                return;
            }

            foreach (ICogJobResultHistory h in mHistoryCollection)
            {
                h.Clear();
            }
        }

        /// <summary>
        /// This method serves to close the VisionControl. 
        /// It unsubscribes from the events of the JobManager instance and calls Shutdwon on it.
        /// Therefore this method should be called only at closing the Vision Application.
        /// </summary>
        public void Close()
        {
            mMinimumGuiPeriodTimer?.Dispose();
            mMaximumGuiPeriodTimer?.Dispose();
            mMinimumGuiPeriodTimer = null;
            mMaximumGuiPeriodTimer = null;
            AttachToJobManager(false);
            Application.DoEvents();
            mIsClosing = true;
            if (mJM != null)
            {
                mJM.Shutdown();
                mJM = null;
            }
        }
        #endregion

        #region Initialization
        /*
         * For the vpp filename, first check using the full path supplied when the application
         * was generated.  This is intended for use primarily on developer machines.  If this
         * filename does not exist, then look in the same directory as the executable for
         * the vpp file, using just the filename portion.  This is the expected deployment
         * configuration.
         * 
         * For other files (such as the about box text file and password text file), first
         * check in the same directory as the vpp file, using the full path supplied when the
         * application was generated.  Then look in the same directory as the executable.
         */
        public VisionUC()
        {
            InitializeComponent();
            SizeChanged += VisionUC_SizeChanged;
            //GpioController controller = new GpioController();
            //controller.OpenPin(pin, PinMode.Output);
            //if (!DesignMode)
            //    this.tabPage1.Controls.Add(new UCOneJob() { Dock = DockStyle.Fill });
            this.uiTabControl1.TabVisible = false;
            tpStat.BackColor = Color.FromArgb(224, 234, 254);
            ucTcpClient1.Received += UcTcpClient1_Received;
            ucTcpServer1.Received += UcTcpClient1_Received;
#if Test
            FillJobTabs();
#endif
        }

        private void UcTcpClient1_Received(string obj)
        {
            if (autoRunMode && obj.Contains(runJobCmd))
            {
                var arr = obj.Split(" ,.;\r\n".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);

                for (int i = 0; i < arr.Length; ++i)
                {
                    if (arr[i] == runJobCmd.TrimEnd())
                    {
                        if (int.TryParse(arr[i + 1], out int jobIndex))
                        {
                            if (mJM != null && mJM.Job(jobIndex).State == CogJobStateConstants.Stopped)
                                ThreadPool.QueueUserWorkItem(_ => this.SafeInvoke(() => RunJob(jobIndex)));
                        }
                        ++i;
                    }
                }
            }
        }

        private void VisionUC_SizeChanged(object sender, EventArgs e)
        {
            uiSplitContainer1.Height = this.Height - 6;
            uiNavBar1.Width = uiSplitContainer1.Panel2.Width;
            uiTabControl1.Width = uiNavBar1.Width;
            uiTabControl1.Height = uiSplitContainer1.Panel2.Height - 6 - uiNavBar1.Bottom;
            flowLayoutPanel1.Width = uiTabControl1.Width - flowLayoutPanel1.Left - 3;
            flowLayoutPanel1.Height = uiTabControl1.Bottom - flowLayoutPanel1.Top - 3;
        }

#if Test
        void FillJobTabs()
        {
            for (int i = tabControl_JobTabs.TabCount; i < 4; i++)
            {
                TabPage tp = new TabPage("Job (未设置)");
                tabControl_JobTabs.TabPages.Add(tp);
                tp.Controls.Add(new UCOneJob(null) { Left = 3, Top = 3, Dock = DockStyle.Fill });
                flowLayoutPanel1.Controls.Add(new UCJobStat() { JobName = tp.Text, BackColor = Color.FromArgb(224, 234, 254) });
            }
            //flowLayoutPanel1.Controls.Add(new UCJobStat() { JobName = "Job (未设置)", BackColor = Color.FromArgb(224, 234, 254) });

        }
#endif

        public event Action<bool> PreviewChanged;
        public void Preview(bool isPreview)
        {
            if (isPreview)
            {
                var jobs = UCJobs.ToArray();
                TableLayoutPanel tlp = tabControl_JobTabs.Parent.Controls.OfType<TableLayoutPanel>().FirstOrDefault();
                if (tlp == null)
                {
                    tlp = new TableLayoutPanel();
                    tlp.ColumnCount = 2;
                    tlp.RowCount = (int)Math.Ceiling((float)jobs.Length / tlp.ColumnCount);
                    tlp.SizeChanged += (_, __) => setCellsSize();
                    tlp.Dock = DockStyle.Fill;
                    for (int i = 0; i < tlp.RowCount; i++)
                        tlp.RowStyles.Add(new RowStyle(SizeType.Absolute));
                    for (int i = 0; i < tlp.ColumnCount; i++)
                        tlp.ColumnStyles.Add(new ColumnStyle(SizeType.Absolute));
                    setCellsSize();
                    tabControl_JobTabs.Parent.Controls.Add(tlp);
                }
                tlp.Controls.AddRange(jobs);
                tlp.Show();
                tabControl_JobTabs.Hide();
                void setCellsSize()
                {
                    for (int i = 0; i < tlp.RowCount; i++)
                    {
                        tlp.RowStyles[i].Height = tabControl_JobTabs.Parent.Height / tlp.RowCount;
                        tlp.ColumnStyles[i].Width = tabControl_JobTabs.Parent.Width / tlp.ColumnCount;
                    }
                }
            }
            else
            {
                int i = 0;
                tabControl_JobTabs.Show();
                tabControl_JobTabs.Parent.Controls.OfType<TableLayoutPanel>().FirstOrDefault()?.Hide();
                foreach (var uj in UCJobs.ToList())
                {
                    tabControl_JobTabs.TabPages[i++].Controls.Add(uj);
                }
            }
            this._IsPreview = isPreview;
            PreviewChanged?.Invoke(isPreview);
        }


        private static string ResolveVppFilename()
        {
            string fname = mVppFilename;

            // check if the developer vpp file path exists
            if (!System.IO.File.Exists(fname))
            {
                // if not, then try the filename in the same directory as this executable
                //string justFilename = System.IO.Path.GetFileName(fname);
                // fname = Utility.GetThisExecutableDirectory() + justFilename;
                //return null;
            }

            return fname;
        }


        IEnumerable<UCOneJob> UCJobs
        {
            get
            {
                if (_IsPreview)
                {
                    foreach (var c in tabControl_JobTabs.Parent.Controls.OfType<TableLayoutPanel>().First().Controls.Cast<UCOneJob>())
                        yield return c;
                }
                for (int i = 0; i < tabControl_JobTabs.TabCount; i++)
                {
                    var c = tabControl_JobTabs.TabPages[i].Controls;
                    if (c.Count == 0)
                        continue;
                    var job = (UCOneJob)c[0];
                    yield return job;
                }
            }
        }
        IEnumerable<UCJobStat> UCJobsStat
        {
            get
            {
                foreach (var stat in flowLayoutPanel1.Controls)
                    if (stat is UCJobStat)
                        yield return (UCJobStat)stat;
            }
        }
        UCOneJob SelectedUcJob => GetUCJob(SelectedTab);
        UCOneJob GetUCJob(int i) => UCJobs.ElementAt(i);

        public event Action<string> ErrorMsgRcv;
        void SetErrorMsg(string text)
        {
            //label_controlErrorMessage.Text = text;
            //label_ResultBar.Text = text;
            //this.toolTip.SetToolTip(label_ResultBar, text);
            ErrorMsgRcv?.Invoke(text);
        }
        private bool PerformRequiredInit()
        {
            // resolve the quickbuild filename
            jobError = null;
            string vppFileToLoad = ResolveVppFilename();
            if (vppFileToLoad == null)
                return false;
            if (!File.Exists(vppFileToLoad) && !File.Exists(mVppFilename))
            {
                // vpp file does not exist in either developer location or current dir
                SetErrorMsg(ResourceUtility.FormatString("RtVppNotFound", vppFileToLoad, mVppFilename));
                return false;
            }

            // create, validate & setup the password file
            string passwordfname = Utility.ResolveAssociatedFilename(mVppFilename, "passwords.txt");
            mCurrentPasswordFile = new PasswordFile(passwordfname);
            if (mCurrentPasswordFile.PasswordFileFound && !mCurrentPasswordFile.PasswordFileValid)
            {
                string quoted = "\"" + mCurrentPasswordFile.PasswordFilename + "\"";
                SetErrorMsg(ResourceUtility.FormatString("RtInvalidPasswordFile", quoted));
                return false;
            }
            mCurrentPasswordFile.SetDefaultPassword(AccessLevel.Administrator, mDefaultAdministratorPassword);
            mCurrentPasswordFile.SetDefaultPassword(AccessLevel.Supervisor, mDefaultSupervisorPassword);

            // load the QuickBuild project file
            try
            {
                var cogObj = CogSerializer.LoadObjectFromFile(vppFileToLoad);
                mJM = (CogJobManager)cogObj;
            }
            catch (Exception ex)
            {
                if (ex.InnerException != null)
                {
                    jobError = ex.InnerException.Message;
                    MessageBoxE.Show(this, jobError);
                }
                SetErrorMsg(ResourceUtility.GetString("RtErrorLoadingVpp") + ex.Message);
                return false;
            }

            mLoadedVppFilename = vppFileToLoad;

            // check for an uninitialized acquisition configuration
            for (int i = 0; i < mJM.JobCount; ++i)
            {
                ((CogJob)mJM.Job(i)).AcquisitionProcessThread.Disposed += AcquisitionProcessThread_Disposed;
                if (mJM.Job(i).AcqFifoState == CogJobAcqFifoStateConstants.Invalid)
                {
                    SetErrorMsg(ResourceUtility.FormatString("RtUninitializedAcq", mLoadedVppFilename));
                    return false;
                }
            }

            return true;
        }

        private void AcquisitionProcessThread_Disposed(object sender, EventArgs e)
        {
        }


        void HideCogRecords() => UCJobs.ToList().ForEach(x => x.cogRecordsDisplay1.Hide());


        private void StartApplication()
        {
            //if (mStarted)
            //  return;

            //mStarted = true;

            mInitError = !PerformRequiredInit();
            if (mInitError)
            {
                HideCogRecords();
                //panel6.Hide();
                UpdateControlsEnabled();
                return;
            }

            // create options file, read
            mCurrentOptionsFile = new OptionsFile();
            mCurrentOptionsFile.Read();

            // set the job manager to always generate user result records, even if nothing
            // was added to the user queue within QuickBuild
            mJM.UserQueueResultCreation = CogUserQueueResultCreationConstants.Always;

            // Flush queues
            Utility.FlushAllQueues(mJM);

            // Set up stats
            for (int i = 0; i < mJM.JobCount; i++)
                mJM.Job(i).ThroughputAlgorithm = CogJobThroughputAlgorithmConstants.MovingAverage;
            ResetStatisticsForAllJobs();
            try
            {
                Wizard_FormLoad();
            }
            catch (System.ArgumentOutOfRangeException)
            {
                // do nothing - handles case where fewer jobs than expected are
                // present in job manager
            }

            try
            {

            }
            catch (System.ArgumentException)
            {
                // do nothing - handles case where logo bitmap is not supplied
            }


            AttachToJobManager(true);
            UpdateGUIForSelectedJobChange(-1);

            // select the first tab page to start
            if (tabControl_JobTabs.TabPages.Count > 0)
                tabControl_JobTabs.SelectedTab = tabControl_JobTabs.TabPages[0];

            SetResultBarCurrent();

            // size result history window to number of jobs (or 8 max)
            const int maxJobsToSizeTo = 8;
            int rowHeight = cogJobResultHistoryCollectionEdit1.SelectorControlHeight;
            int totalHeight = rowHeight * (mJM.JobCount > maxJobsToSizeTo ? maxJobsToSizeTo : mJM.JobCount) + 8;

            if (mJM.JobCount > maxJobsToSizeTo)
            {
                // scale height of each row to fit remaining jobs (up to 10)
                const int maxJobsToScaleTo = 10;
                int scaleToFit = mJM.JobCount > maxJobsToScaleTo ? maxJobsToScaleTo : mJM.JobCount;
                int controlSpace = cogJobResultHistoryCollectionEdit1.Height - 4;
                cogJobResultHistoryCollectionEdit1.SelectorControlHeight = controlSpace / scaleToFit;
            }

            // setup the gui update timers
            mMaximumGuiPeriodTimer = new System.Threading.Timer(new System.Threading.TimerCallback(mMaximumGuiPeriodTimer_Elapsed), null,
              MaximumPeriodMs, MaximumPeriodMs);
            mMinimumGuiUpdateNeeded = false;
            mHaveUnpaintedResults = false;
            mMinimumGuiPeriodTimer = new System.Threading.Timer(new System.Threading.TimerCallback(mMinimumGuiPeriodTimer_Elapsed), null,
              MinimumPeriodMs, MinimumPeriodMs);

            // call required IO function
            mJM.IOPostLoadSetup(true);

            // enable IO if selected by options file
            if (mCurrentOptionsFile.EnableIOAtStartup)
            {
                try
                {
                    mJM.IOEnable = true;
                }
                catch (Cognex.VisionPro.Exceptions.CogException)
                { }
            }

            // start heartbeats, if QuickBuild app is configured for them
            mJM.RequestHeartbeat();
        }

        private void VisionControl_Load(object sender, EventArgs e)
        {
            // perform initialization to update the control gui - remainder of initialization
            // takes place in StartApplication
            //if (mUsePasswords)
            //    CurrentAccessLevel = AccessLevel.Operator;
            //else
            //{
            //    CurrentAccessLevel = AccessLevel.Administrator;

            //}

            //this.button_About.Text = ResourceUtility.GetString("RtAboutButton");
            //this.button_Chose.Text = ResourceUtility.GetString("RtChoseButton");
            //this.button_Configuration.Text = ResourceUtility.GetString("RtConfigurationButton");
            //this.checkBox_LiveDisplay.Text = ResourceUtility.GetString("RtLiveImageButton");
            //this.button_SaveSettings.Text = ResourceUtility.GetString("RtSaveSettingsButton");

            //this.label_Login.Text = ResourceUtility.GetString("RtCurrentLogin");

            //comboBox_Login.Items.Add(new AccessLevel_Localized(AccessLevel.Operator, ResourceUtility.GetString("RtOperator")));
            //comboBox_Login.Items.Add(new AccessLevel_Localized(AccessLevel.Supervisor, ResourceUtility.GetString("RtSupervisor")));
            //comboBox_Login.Items.Add(new AccessLevel_Localized(AccessLevel.Administrator, ResourceUtility.GetString("RtAdministrator")));
            //comboBox_Login.SelectedIndex = 0;


            this.mResultTextHash = new Hashtable();
            this.mResultTextHash.Add(CogToolResultConstants.Accept, ResourceUtility.GetString("RtAccept"));
            this.mResultTextHash.Add(CogToolResultConstants.Warning, ResourceUtility.GetString("RtWarning"));
            this.mResultTextHash.Add(CogToolResultConstants.Reject, ResourceUtility.GetString("RtReject"));
            this.mResultTextHash.Add(CogToolResultConstants.Error, ResourceUtility.GetString("RtError"));

            if (!DesignMode)
                StartApplication();
        }

        public void AttachToJobManager(bool attach)
        {
            // attach and detach our event handlers/etc
            if (attach)
            {
                if (mAttached)
                    return;

                try
                {
                    Wizard_AttachPropertyProviders();
                }
                catch (System.ArgumentOutOfRangeException)
                {
                    // do nothing - handles case where fewer jobs than expected are
                    // present in job manager
                }

                mAttached = true;

                // Create a collection of history items for each job.
                // Preserve the history of any jobs that we already have - create new items for any
                // new jobs.
                CogJobResultHistoryCollection jobs = new CogJobResultHistoryCollection();
                bool changed = false;
                for (int j = 0; j < mJM.JobCount; ++j)
                {
                    int i = mHistoryCollection.IndexOf(mJM.Job(j).Name);
                    if (i != -1)
                    {
                        if (i != jobs.Count) changed = true;
                        jobs.Add(mHistoryCollection[i]);
                    }
                    else
                    {
                        jobs.Add(new CogJobResultHistoryGated(mJM.Job(j).Name, AllQueueLength, FailureQueueLength));
                        changed = true;
                    }
                }
                if (jobs.Count != mHistoryCollection.Count)
                    changed = true;
                if (changed)
                {
                    mHistoryCollection = jobs;
                    cogJobResultHistoryCollectionEdit1.Subject = jobs;
                    mSelectedJob = 0;
                }

                foreach (CogJobResultHistoryGated hist in mHistoryCollection)
                {
                    hist.CurrentItemChanged += new EventHandler(cogJobResultHistory_CurrentItemChanged);
                    hist.InternalQueue.CurrentQueueChanged += new EventHandler(cogJobResultHistory_RequestImmediateUpdate);
                    hist.InternalQueue.CurrentItemChanged += new EventHandler(cogJobResultHistory_RequestImmediateUpdate);
                }
                mJM.Stopped += new CogJobManager.CogJobManagerStoppedEventHandler(mJM_Stopped);
                mJM.UserResultAvailable += new CogJobManager.CogUserResultAvailableEventHandler(mJM_UserResultAvailable);
                mJM.Changed += new CogChangedEventHandler(mJM_ChangedHandler);

                for (int i = 0; i < mJM.JobCount; ++i)
                {
                    mJM.Job(i).Running += new CogJob.CogJobRunningEventHandler(Job_Running);
                    mJM.Job(i).ImageQueueOverflowed += new CogJob.CogImageQueueOverflowedEventHandler(Job_ImageQueueOverflowed);
                    mJM.Job(i).Stopped += CogJob_Stopped;
                }

                // pull off and handle any items currently in the UserQueue
                HandleUserResults(null, null);

                // update the state of controls to reflect any changes made in config mode
                UpdateControlsEnabled();
                UpdateOnlineStatus();
            }
            else
            {
                if (!mAttached)
                    return;

                Wizard_DetachPropertyProviders();
                mAttached = false;

                foreach (CogJobResultHistoryGated hist in mHistoryCollection)
                {
                    hist.CurrentItemChanged -= new EventHandler(cogJobResultHistory_CurrentItemChanged);
                    hist.InternalQueue.CurrentQueueChanged -= new EventHandler(cogJobResultHistory_RequestImmediateUpdate);
                    hist.InternalQueue.CurrentItemChanged -= new EventHandler(cogJobResultHistory_RequestImmediateUpdate);
                }

                mJM.Stopped -= new CogJobManager.CogJobManagerStoppedEventHandler(mJM_Stopped);
                mJM.UserResultAvailable -= new CogJobManager.CogUserResultAvailableEventHandler(mJM_UserResultAvailable);
                mJM.Changed -= new CogChangedEventHandler(mJM_ChangedHandler);

                for (int i = 0; i < mJM.JobCount; ++i)
                {
                    mJM.Job(i).Running -= new CogJob.CogJobRunningEventHandler(Job_Running);
                    mJM.Job(i).ImageQueueOverflowed -= new CogJob.CogImageQueueOverflowedEventHandler(Job_ImageQueueOverflowed);
                    mJM.Job(i).Stopped -= CogJob_Stopped;
                }
            }
        }

        private void CogJob_Stopped(object sender, CogJobActionEventArgs e)
        {
            // stopWatch.Stop();
            CogJob job = (CogJob)sender;
            int i = Utility.GetJobIndexFromName(mJM, job.Name);
            var stat = UCJobsStat.ElementAt(i);
            if (stat.StopWatch.IsRunning)
            {
                stat.Stop();
                SetElapseText(i, true);
                stat.Reset();
            }
            var ucJob = GetUCJob(i);
            ucJob.SafeInvoke(() => ucJob.UpdateUIStat(job.State));


            if (AllJobsStop())
            {
                var cc = mCurrentRunState == RunState.RunningContinuous ? CogActionConstants.StoppedContinuous : CogActionConstants.StoppedSingle;
                mJM_Stopped(mJM, new CogJobManagerActionEventArgs(job, cc));
            }
            log.Info($"Job[{i}]“{job.Name}”已停止运行");
        }
        #endregion
        bool AllJobsStop()
        {
            if (mJM == null)
                return false;
            //for(int i = 0; i < mJM.JobCount; ++i)
            //{
            //    if(mJM.Job(i).State != CogJobStateConstants.Stopped)
            //        return false;
            //}
            return mJM.JobsRunningState == CogJobsRunningStateConstants.None;

        }
        #region Runtime implementation
        //ILog log => LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);

        public void RunOnce()
        {
            if (!CheckJob())
            {
                return;
            }
            if (mJM.JobsRunningState != CogJobsRunningStateConstants.None)
                return;

            // update control state here to prevent an error from a quick button doubleclick
            mCurrentRunState = RunState.RunningOnce;
            UpdateControlsEnabled(false);

            try
            {
                var job = mJM.Job(SelectedTab);
                var tools = (job.VisionTool as CogToolGroup)?.Tools;
                if (tools != null)
                {
                    foreach (var tool in tools)
                    {
                        if (tool is CogAcqFifoTool)
                        {
                            // var fifoTool = ((CogAcqFifoTool)tool); 
                            // fifoTool.Ran += FifoTool_Ran;
                            //fifoTool.Running += (_,__)=>Job_Running(sender, new CogJobActionEventArgs( CogActionConstants.RunningSingle)); ;
                            // fifoTool.Run();
                            //mJM.Job(0).RunMode = CogJobRunModeConstants.ImageProcessingOnly;
                            // return;
                        }
                    }
                }
                stopWatch.Start();
                foreach (var sta in UCJobsStat)
                    sta.Start();
                mJM.Run();

                // note that mJM_Stopped will be called when run is complete
            }
            catch (Cognex.VisionPro.Exceptions.CogNotStoppedException)
            {
                // do nothing in this case - we're already running
            }
            catch (Cognex.VisionPro.Exceptions.CogException ex)
            {
                mCurrentRunState = RunState.Stopped;
                UpdateControlsEnabled(true);
                log.Error(ex);
                MessageBoxE.Show(this, ResourceUtility.GetString("RtUnexpectedErrorQB") + ex.Message,
                  mApplicationName);
            }
        }

        private void FifoTool_Ran(object sender, EventArgs e)
        {
            ICogTool tool = (ICogTool)sender;
            SelectedUcJob.cogRecordDisplay1.Record = tool.CreateLastRunRecord().SubRecords[0];
        }

        public void RunCont()
        {
            if (!CheckJob())
                return;
            if (mCurrentRunState == RunState.RunningContinuous)
            {
                // Stop continuous
                mJM.Stop();

                // note that mJM_Stopped will be called when job manager has completed this stop
                // request
            }
            else
            {
                // update control state here to prevent an error from a quick button doubleclick
                mCurrentRunState = RunState.RunningContinuous;
                UpdateControlsEnabled(true);

                try
                {
                    if (SelectedTab < mJM.JobCount)
                    {
                        var tools = (mJM.Job(SelectedTab).VisionTool as CogToolGroup)?.Tools;
                        if (tools != null)
                        {
                            foreach (var tool in tools)
                            {
                                if (tool is CogAcqFifoTool)
                                {
                                    //var fifoTool = ((CogAcqFifoTool)tool);
                                    //fifoTool.Ran += FifoTool_Ran;
                                    //fifoTool.Running += (_, __) => Job_Running(sender, new CogJobActionEventArgs(CogActionConstants.RunningContinuous)); ;
                                    //fifoTool.Run();
                                    //return;
                                }
                            }
                        }
                    }
                    stopWatch.Start();
                    foreach (var sta in UCJobsStat)
                        sta.Start();
                    mJM.RunContinuous();
                    _IsAllRun = true;
                }
                catch (Cognex.VisionPro.Exceptions.CogNotStoppedException)
                {
                    // do nothing in this case - we're already running
                }
                catch (Cognex.VisionPro.Exceptions.CogException ex)
                {
                    mCurrentRunState = RunState.Stopped;
                    UpdateControlsEnabled(true);
                    log.Error(ex);
                    MessageBoxE.Show(this, ResourceUtility.GetString("RtUnexpectedErrorQB") + ex.Message,
                      mApplicationName);
                }
            }
        }
        public void RunJob(int i, bool once = true)
        {
            if (!CheckJob())
                return;
            if (i >= mJM.JobCount)
            {
                MessageBoxE.Show(this, "当前所选Job未配置");
                return;
            }
            var job = mJM.Job(i);
            if (job.State != CogJobStateConstants.Stopped)
            {
                log.Info($"执行停止Job[{i}]“{job.Name}”操作");
                // Stop continuous
                job.Stop();

                // note that mJM_Stopped will be called when job manager has completed this stop
                // request
            }
            else
            {
                var oldState = mCurrentRunState;
                // update control state here to prevent an error from a quick button doubleclick
                if (mCurrentRunState == RunState.Stopped || AllJobsStop())
                    mCurrentRunState = once ? RunState.RunningOnce : RunState.RunningContinuous;

                try
                {
                    var tools = (mJM.Job(SelectedTab).VisionTool as CogToolGroup)?.Tools;
                    if (tools != null)
                    {
                        foreach (var tool in tools)
                        {
                            if (tool is CogAcqFifoTool)
                            {
                                //var fifoTool = ((CogAcqFifoTool)tool);
                                //fifoTool.Ran += FifoTool_Ran;
                                //fifoTool.Running += (_, __) => Job_Running(sender, new CogJobActionEventArgs(CogActionConstants.RunningContinuous)); ;
                                //fifoTool.Run();
                                //return;
                            }
                        }
                    }
                    if (oldState == RunState.Stopped)
                    {
                        stopWatch.Start();
                    }
                    UCJobsStat.ElementAt(i).Start();
                    if (once)
                    {
                        log.Info($"执行单次运行Job[{i}]“{job.Name}”操作");
                        job.Run();
                    }
                    else
                    {
                        log.Info($"执行持续运行Job[{i}]“{job.Name}”操作");
                        job.RunContinuous();
                    }
                }
                catch (Cognex.VisionPro.Exceptions.CogNotStoppedException)
                {
                    // do nothing in this case - we're already running
                }
                catch (Cognex.VisionPro.Exceptions.CogException ex)
                {
                    mCurrentRunState = RunState.Stopped;
                    //UpdateControlsEnabled();
                    log.Error($"Job[{i}]“{job.Name}”运行出错。" + ex);
                    MessageBoxE.Show(this, ResourceUtility.GetString("RtUnexpectedErrorQB") + ex.Message,
                      mApplicationName);
                }
                catch (Exception ex)
                {

                }
            }
            SetElapseText(i, true);

            UpdateControlsEnabled();
        }
        public event Action<RunState> RunStateUpdated;
        public void UpdateControlsEnabled(bool force = false)
        {
            // Enable or disable controls based on our current run state
            bool running = mCurrentRunState != RunState.Stopped;
            bool runningLive = mCurrentRunState == RunState.RunningLive;
            bool runningContinuous = mCurrentRunState == RunState.RunningContinuous;
            bool currentJobCanLive = mJM != null && mJM.JobCount > mSelectedJob && mJM.Job(mSelectedJob).AcqFifo != null;

            bool canConfig = !running && CurrentAccessLevel == AccessLevel.Administrator;
            bool canSaveSettings = !running && CurrentAccessLevel >= AccessLevel.Supervisor;
            RunStateUpdated?.Invoke(mCurrentRunState);


            // live display button is enabled if the current job can run live and either
            //   we're not running and the live display button is "up" or
            //   we are running and the live display button is "down"
            checkBox_LiveDisplay.Enabled = !mInitError && currentJobCanLive &&
              ((mCurrentRunState == RunState.Stopped && checkBox_LiveDisplay.Checked == false) ||
               (mCurrentRunState == RunState.RunningLive && checkBox_LiveDisplay.Checked == true));


            //button_ResetStatistics.Enabled = !mInitError && !runningLive;
            //button_ResetStatisticsForAllJobs.Enabled = !mInitError && !runningLive;

            Wizard_EnableControls(running);

            // update the monitor window for live display
            int count = mJM == null ? 0 : mJM.JobCount;
            for (int j = 0; j < count; ++j)
            {
                if (j < cogJobResultHistoryCollectionEdit1.SelectorControls.Count)
                {
                    Control ctl = (Control)cogJobResultHistoryCollectionEdit1.SelectorControls[mHistoryCollection[j]];
                    if (runningLive)
                    {
                        bool waitingForStop = !checkBox_LiveDisplay.Enabled;
                        ctl.Enabled = !waitingForStop && (mJM.Job(j).AcqFifo != null) &&
                          (j == mSelectedJob || mJM.Job(j).State == CogJobStateConstants.Stopped);
                    }
                    else
                        ctl.Enabled = true;
                }
                var ucjob = UCJobs.ElementAt(j);
                var state = force ?
                    (running ?
                    (runningContinuous ? CogJobStateConstants.RunningContinuous : CogJobStateConstants.RunningSingle) : CogJobStateConstants.Stopped)
                   : mJM.Job(j).State;
                ucjob.SafeInvoke(() => ucjob.UpdateUIStat(state));
            }
        }

        private void UpdateOnlineStatus()
        {
            // update the online/offline status indication

            // check if update needed
            if (label_Online.Tag != null && (bool)label_Online.Tag == mJM.IOEnable)
                return;

            string resStr = mJM.IOEnable ? "RtSystemOnline" : "RtSystemOffline";
            string displayStr = ResourceUtility.GetString(resStr);
            label_Online.Text = displayStr;
            label_Online.Tag = mJM.IOEnable;
        }

        private void HandleUserResults(object sender, CogJobManagerActionEventArgs e)
        {
            // take the latest result and push it into a queue

            ICogRecord result = mJM.UserResult();
            if (result != null)
            {
                string jobName = (string)result.SubRecords["JobName"].Content;
                int jobIndex = Utility.GetJobIndexFromName(mJM, jobName);
                // note - ignore unknown job names
                if (jobIndex >= 0)
                {
                    // push the result into the appropriate history queue
                    mHistoryCollection[jobIndex].AddNewUserResult(result);

                    // pass the result on to any listeners
                    VisionControlUserResultAvailableEventHandler delegateCopy = VisionControlUserResultAvailable;
                    if (delegateCopy != null)
                    {
                        delegateCopy(this, new VisionControlUserResultAvailableEventArgs(jobIndex, result));
                    }

                    lock (mMinimumGuiPeriodTimer)
                    {
                        mHaveUnpaintedResults = true;
                    }
                }
                //====================
                this.Invoke(new Action(() =>
                {
                    myTG = mJM.Job(jobIndex).VisionTool as Cognex.VisionPro.ToolGroup.CogToolGroup;

                    var MyToolBlock = myTG.Tools["CogToolBlock1"] as Cognex.VisionPro.ToolBlock.CogToolBlock;

                    //   var MyToolBlock = myTG.Tools["CogToolBlock1"] as CogToolGroup;  //NG显示
                    //var t2 = myTG.Tools["CogResultsAnalysisTool1"] as CogResultsAnalysisTool;
                    var records = myTG.CreateLastRunRecord().SubRecords;
                    var cogDisp = GetUCJob(jobIndex).cogRecordDisplay1;
                    cogDisp.Record = records[0];
                    /* var img= records[0].Content as ICogImage;
                       if(img!= null)
                          pictureBox1.Image= img.ToBitmap();
  */
                    if (MyToolBlock == null)
                        return;
                    if (MyToolBlock.Outputs["Output"] == null)
                        return;
                    //if ("False".Equals(MyToolBlock.Outputs["Output"].Value.ToString()))
                    //{
                    //    //Fit()将缩放图像及其图形以适应显示控件。
                    //    cogDisp.Fit();
                    //}
                    //else
                    //{
                    //    pushDO("0x01");
                    //}
                    //延迟1mm
                    Thread.Sleep(1);
                    pushDO("0x00");

                }));
                //====================
            }
        }
        //====================
        //0x01 OK  0x02 NG 0x00 reset
        private void pushDO(string data)
        {
            return;
            //-----------------------------------------------------------------------------------
            // Configure the following parameters before running the demo
            //-----------------------------------------------------------------------------------
            //The default device of project is demo device, users can choose other devices according to their needs. 
            string deviceDescription = "PCIE-1730,BID#0";
            string profilePath = "C:/fz/Device.xml";
            int startPort = 0;
            int portCount = 1;
            ErrorCode errorCode = ErrorCode.Success;

            // Step 1: Create a 'InstantDoCtrl' for DO function.
            InstantDoCtrl instantDoCtrl = new InstantDoCtrl();
            try
            {
                // Step 2: Select a device by device number or device description and specify the access mode.
                // in this example we use ModeWrite mode so that we can fully control the device, including configuring, sampling, etc.
                instantDoCtrl.SelectedDevice = new DeviceInformation(deviceDescription);
                errorCode = instantDoCtrl.LoadProfile(profilePath);//Loads a profile to initialize the device.
                if (BioFailed(errorCode))
                {
                    throw new Exception();
                }

                // Step 3: Write DO ports
                //DioPort[] dioPort = instantDoCtrl.Ports;
                //dioPort[0].DirectionMask = 0xFF; //Setting port0 direction
                byte[] bufferForWriting = new byte[64];
                //byte dataForWriteBit = 0;//data is used to the 'WriteBit'.
                //int bit = 1;//the bit is used to the 'WriteBit'.

                for (int i = 0; i < portCount; ++i)
                {
                    Console.WriteLine("Input a hexadecimal number for DO port {0} to output(for example, 0x11): ", startPort + i);
                    bufferForWriting[i] = byte.Parse(data.Contains("0x") ? data.Remove(0, 2) : data, System.Globalization.NumberStyles.HexNumber);
                    /*
                     //for WriteBit
                     Console.WriteLine(" Input a hexadecimal number for DO port {0} to output(for example, 0x1 or 0x00): ", startPort + i);
                     string data = Console.ReadLine();
                     dataForWriteBit = byte.Parse(data.Contains("0x") ? data.Remove(0, 2) : data, System.Globalization.NumberStyles.HexNumber);
                    */
                }
                errorCode = instantDoCtrl.Write(startPort, portCount, bufferForWriting);
                /************************************************************************/
                //errorCode = instantDoCtrl.WriteBit(startPort, bit, dataForWriteBit); 
                //NOTE:
                //Every channel has 8 bits, which be used to control 0--7 bit of anyone channel.
                //argument1:which port you want to contrl? For example, startPort is 0.
                //argument2:which bit you want to control? You can write 0--7, any number you want.
                //argument3:What status you want, open or close? 1 menas open, 0 means close.*/
                /************************************************************************/
                if (BioFailed(errorCode))
                {
                    throw new Exception();
                }
                Console.WriteLine("DO output completed !");
                // Read back the DO status. 
                // Note: 
                // For relay output, the read back must be deferred until the relay is stable.
                // The delay time is decided by the HW SPEC.
                // byte[] bufferForReading = new byte[64];
                // instantDoCtrl.DoRead(startPort, portCount, bufferForReading);
                // if (BioFailed(errorCode))
                // {
                //    throw new Exception();
                // }
                // Show DO ports' status
                // for (int i = startPort; i < portCount + startPort; ++i)
                // {
                //    Console.WriteLine("Now, DO port {0} status is:  0x{1:x}", i, bufferForReading[i - startPort]);
                // }
            }
            catch (Exception ex)
            {
                // Something is wrong
                string errStr = BioFailed(errorCode) ? " Some error occurred. And the last error code is " + errorCode.ToString()
                                                           : ex.Message;
                Console.WriteLine(errStr);
            }
            finally
            {
                // Step 4: Close device and release any allocated resource.
                instantDoCtrl.Dispose();
                //Console.ReadKey(false);
            }
        }

        //没啥用，别删，删了报错。
        static bool BioFailed(ErrorCode err)
        {
            return err < ErrorCode.Success && err >= ErrorCode.ErrorHandleNotValid;
        }
        //====================

        private void mJM_UserResultAvailable(object sender, CogJobManagerActionEventArgs e)
        {
            HandleUserResults(sender, e);
            UpdateGuiIfNeeded();
        }

        private void mJM_ImageAvailable(object sender, CogJobActionEventArgs e)
        {
            // called when new images are available in live video mode only

            try
            {
                if (this.InvokeRequired)
                {
                    // Call this same function on the GUI thread.
                    // Invoke currently has a bug, and it is fixed in .NET2.0
                    IAsyncResult async = BeginInvoke(new CogJob.CogImageAvailableEventHandler(mJM_ImageAvailable), new object[] { sender, e });
                    while (!async.IsCompleted && !async.AsyncWaitHandle.WaitOne(300, false)) ;
                    EndInvoke(async);
                    return;
                }

                // display the image if it is from the currently selected job (otherwise ignore it)
                CogJob j = (CogJob)sender;
                int idx = Utility.GetJobIndexFromName(mJM, j.Name);
                //if (idx == mSelectedJob)
                //    cogRecordsDisplay1.Display.Image = j.Image();
                GetUCJob(idx).cogRecordsDisplay1.Display.Image = j.Image();
            }
            catch { }
        }

        private void Job_Running(object sender, CogJobActionEventArgs e)
        {
            // handles:
            //   - gui updates for job run commands issued via IO

            try
            {
                if (this.InvokeRequired)
                {
                    // Call this same function on the GUI thread.
                    // No need to wait for it here, so ignore the asyncresult return value and return immediately
                    BeginInvoke(new CogJob.CogJobRunningEventHandler(Job_Running), new object[] { sender, e });
                    return;
                }

                // if we are getting this event because the live button was pressed, then we don't have
                // any work to do
                bool isLive = mCurrentRunState == RunState.RunningLive;
                if (isLive)
                    return;
                var job = (CogJob)sender;
                RunState newrunstate = RunState.Stopped;

                switch (e.Action)
                {
                    case CogActionConstants.RunningContinuous:
                        newrunstate = RunState.RunningContinuous;
                        break;
                    case CogActionConstants.RunningSingle:
                        newrunstate = RunState.RunningOnce;
                        break;
                    default:
                        break;
                }

                // only perform gui changes if we haven't done them already
                if (mCurrentRunState != newrunstate)
                {
                    mCurrentRunState = newrunstate;
                    UpdateControlsEnabled();
                }
                int jobInd = Utility.GetJobIndex(mJM, job);
                UCJobs.ElementAt(jobInd).UpdateUIStat(job.State);
                var runType = job.State == CogJobStateConstants.RunningContinuous ? "连续" : "单次";
                log.Info($"Job[{jobInd}]“{job.Name}”已启动{runType}运行");
            }
            catch { }
        }

        private void mJM_Stopped(object sender, CogJobManagerActionEventArgs e)
        {
            // handles:
            //    - exit from continuous mode
            //    - completion of a single run ("run once")
            //    - exit from live mode

            try
            {
                if (this.InvokeRequired)
                {
                    // Call this same function on the GUI thread.
                    // No need to wait for it here, so ignore the asyncresult return value and return immediately
                    BeginInvoke(new CogJobManager.CogJobManagerStoppedEventHandler(mJM_Stopped), new object[] { sender, e });
                    return;
                }

                bool stoppingLive = mCurrentRunState == RunState.RunningLive || checkBox_LiveDisplay.Checked;

                mCurrentRunState = RunState.Stopped;
                _IsAllRun = false;
                if (stopWatch.IsRunning)
                {
                    stopWatch.Stop();
                    SetElapseText(null, true);

                    stopWatch.Reset();
                    log.Info("所有Job已停止运行");
                }
                if (stoppingLive)
                {
                    RestoreJobStates();

                    // clear any statistics
                    ResetStatisticsForAllJobs();

                    // go back to displaying last result for selected job
                    foreach (var ucjob in UCJobs)
                    {
                        ucjob.cogRecordsDisplay1.Subject = null;
                        ucjob.cogRecordsDisplay1.Display.Image = null;
                    }
                    UpdateGUIForSelectedJob(true);

                    // Need to make sure the checkbox back to unchecked, in case the stopped event is occurring due
                    // to IO, instead of a button click.
                    // Note that this may cause a "checked == false" event to occur.
                    checkBox_LiveDisplay.Checked = false;
                }

                UpdateGui(null, null);
                UpdateControlsEnabled(true);
                SetResultBarCurrent();
            }
            catch { }
        }
        void SetElapseText(int? i = null, bool milliseconds = false)
        {
            string fmt = @"hh\:mm\:ss" + (milliseconds ? @"\.fff" : string.Empty);
            if (i.HasValue)
            {
                if (i == -1)
                {
                    foreach (var jobStat in UCJobsStat)
                        jobStat.SafeInvoke(() => jobStat.ElapsedText = jobStat.Elapsed.ToString(fmt));
                }
                else
                {
                    var jobStat = UCJobsStat.ElementAt(i.Value);
                    jobStat.SafeInvoke(() => jobStat.ElapsedText = jobStat.Elapsed.ToString(fmt));
                }
            }
            else
            {
                tbElapse.SafeInvoke(() => tbElapse.Text = stopWatch.Elapsed.ToString(fmt));
            }
        }
        private void mJM_JobStopped(object sender, CogJobActionEventArgs e)
        {
            if (e.Action == CogActionConstants.StoppedContinuous ||
               e.Action == CogActionConstants.RunningContinuous)
            {
                try
                {
                    if (this.InvokeRequired)
                    {
                        // Call this same function on the GUI thread.
                        // No need to wait for it here, so ignore the asyncresult return value and return immediately
                        BeginInvoke(new CogJob.CogJobStoppedEventHandler(mJM_JobStopped), new object[] { sender, e });
                        return;
                    }

                    UpdateControlsEnabled();
                }
                catch { }
            }
        }

        private void mJM_ChangedHandler(object sender, CogChangedEventArgs e)
        {
            if ((e.StateFlags & CogJobManager.SfIOEnable) != 0)
            {
                lock (mMinimumGuiPeriodTimer)
                {
                    mMinimumGuiUpdateNeeded = true;
                }
            }
        }

        private int FindResultHistoryIndex(object sender)
        {
            int jobIndex;
            for (jobIndex = 0; jobIndex < mHistoryCollection.Count; ++jobIndex)
                if (Object.ReferenceEquals(sender, mHistoryCollection[jobIndex]))
                    break;
            if (jobIndex == mHistoryCollection.Count)
                return -1;  // unknown job
            return jobIndex;
        }

        private CogJobResultHistoryEdit FindResultHistoryEdit(CogJob job)
        {
            int jobIndex = Utility.GetJobIndexFromName(mJM, job.Name);
            Cognex.VisionPro.Implementation.Internal.CogToggleButton item =
                (Cognex.VisionPro.Implementation.Internal.CogToggleButton)
                cogJobResultHistoryCollectionEdit1.SelectorControls[mHistoryCollection[jobIndex]];
            return item.Content as CogJobResultHistoryEdit;
        }

        private void Job_ImageQueueOverflowed(object sender, CogJobActionEventArgs e)
        {
            // sets gui "error occurred" icon for given job to "on"
            try
            {
                CogJobResultHistoryEdit edit = FindResultHistoryEdit((CogJob)sender);
                if (!edit.ErrorIconVisible)
                {
                    edit.ErrorIconVisible = true;
                    edit.ErrorIconClicked += new EventHandler(cogJobResultHistory_ErrorIconClicked);
                }
            }
            catch { }
        }

        private void cogJobResultHistory_ErrorIconClicked(object sender, System.EventArgs e)
        {
            ICogJobResultHistory history = ((CogJobResultHistoryEdit)sender).Subject;

            // get job name
            int jobIndex = FindResultHistoryIndex(history);
            if (jobIndex < 0)
                return;

            string jobname = mJM.Job(jobIndex).Name;

            // for now, show a brief error message.  in the future, we may bring up a more
            // flexible error log here
            MessageBoxE.Show(this, ResourceUtility.FormatString("RtImageQueueOverrun", jobname),
              mApplicationName, MessageBoxButtons.OK);

            // since the message has been viewed, now clear the sender's error icon display
            CogJobResultHistoryEdit edit = FindResultHistoryEdit(mJM.Job(jobIndex));
            edit.ErrorIconVisible = false;
            edit.ErrorIconClicked -= new EventHandler(cogJobResultHistory_ErrorIconClicked);
        }

        private void UpdateGUIForSelectedJobChange(int oldJob)
        {
            // update the gui when the user changes the currently selected job

            TabPage oldSelected = this.tabControl_JobTabs.SelectedTab;
            ArrayList newPagesList = new ArrayList();

            // add in the tabs for the selected job
            // set the selected job text
            Wizard_AddJobTabs(newPagesList);

            // remove all the tabs
            tabControl_JobTabs.Controls.ClearAndDispose();
            flowLayoutPanel1.Controls.ClearAndDispose();

            // add in the tabs available at current access level
            //添加Job Tab页面
            //foreach (TabPage page in newPagesList)
            //{
            //    if (page.Tag == null || Utility.AccessAllowed(page.Tag.ToString(), mCurrentAccessLevel))
            //        tabControl_JobTabs.Controls.Add(page);
            //}
            if (mJM != null && mJM.JobCount > 0)
            {
                for (int i = 0; i < tabControl_JobTabs.TabCount; i++)
                    tabControl_JobTabs.TabPages[i].Dispose();
                tabControl_JobTabs.TabPages.Clear();
                flowLayoutPanel1.Controls.ClearAndDispose();
                for (int i = 0; i < mJM.JobCount; i++)
                {
                    var job = mJM.Job(i);
                    TabPage tp = new TabPage(job.Name) { Name = job.Name };
                    tabControl_JobTabs.TabPages.Add(tp);
                    var ucJob = new UCOneJob(job) { Index = i, Left = 3, Top = 3, Dock = DockStyle.Fill };
                    ucJob.RunClicked += () => RunJob(ucJob.Index);
                    tp.Controls.Add(ucJob);
                    flowLayoutPanel1.Controls.Add(new UCJobStat() { JobName = job.Name, BackColor = Color.FromArgb(224, 234, 254) });
                }
                flowLayoutPanel1.Controls.Add(new Panel() { Height = 100, BackColor = Color.Transparent });
#if Test
                FillJobTabs();
#endif
            }
            if (tabControl_JobTabs.TabCount > 0)
                tabControl_JobTabs.SelectedIndex = 0;
            //作业执行统计页面 

            if (tabControl_JobTabs.TabPages.Contains(oldSelected))
                this.tabControl_JobTabs.SelectedTab = oldSelected;
            else if (tabControl_JobTabs.TabPages.Count > 0)
                this.tabControl_JobTabs.SelectedTab = tabControl_JobTabs.TabPages[0];

            // handle job change while live video enabled
            if (this.mCurrentRunState == RunState.RunningLive && oldJob >= 0)
            {
                // start new job
                this.StartLiveDisplay(mSelectedJob);
                // stop old job
                this.StopLiveDisplay(oldJob);
            }

            UpdateControlsEnabled();
            UpdateStatisticsForJob(mSelectedJob);
        }

        private static string[] _updateDisplayStrings = new string[] { "ShowLastRunRecordForUserQueue", "LastRun" };
        private bool autoRunMode = true;
        private AccessLevel mCurrentAccessLevel;

        private void UpdateGUIForSelectedJob(bool newSelectedJob)
        {
            // update the image and result bar to reflect the currently selected item of the
            // the currently selected job

            ICogRecord result = mHistoryCollection[mSelectedJob].CurrentItem;
            if (result == null)
                return;

            if (mCurrentRunState != RunState.RunningLive)
            {
                if (mCurrentOptionsFile.EnableImageDisplay)
                {
                    // take the LastRunRecord (for the currently selected job) and put it in the record display.
                    // put an empty record in if no LastRunRecord is available
                    //if (!Utility.AddRecordToDisplay(cogRecordsDisplay1, result, _updateDisplayStrings, newSelectedJob))
                    //    cogRecordsDisplay1.Subject = null;
                }
                //else
                //    cogRecordsDisplay1.Subject = null;
            }

            SetResultBarCurrent();
        }

        private void UpdateGUIForJob(int idx)
        {
            // update the tab pages to reflect the currently selected item of the the currently
            // selected job

            ICogRecord result = mHistoryCollection[idx].CurrentItem;

            // fill in the tab results
            Wizard_UpdateJobResults(idx, result);
        }

        private void SetResultBarCurrent()
        {
            string text;
            CogRunStatus rs = null;

            text = mJM.Job(mSelectedJob).Name;

            if (mCurrentRunState == RunState.RunningLive)
                text += ": " + ResourceUtility.GetString("RtLiveImageButton");
            else
            {
                ICogRecord result = mHistoryCollection[mSelectedJob].CurrentItem;

                if (result != null)
                {
                    rs = (CogRunStatus)result.SubRecords["RunStatus"].Content;

                    text += ": " + (string)this.mResultTextHash[rs.Result];
                }
            }

            //label_ResultBar.Text = text;
            //label_ResultBar.BackColor = GetColorFromRunStatus(rs);
        }

        private System.Drawing.Color GetColorFromRunStatus(CogRunStatus status)
        {
            System.Drawing.Color color;
            if (status != null)
            {
                switch (status.Result)
                {
                    case CogToolResultConstants.Accept:
                        color = System.Drawing.Color.FromArgb(0, 200, 0);
                        break;
                    case CogToolResultConstants.Warning:
                        color = System.Drawing.Color.Yellow;
                        break;
                    case CogToolResultConstants.Reject:
                    case CogToolResultConstants.Error:
                    default:
                        color = System.Drawing.Color.Red;
                        break;
                }
            }
            else
                color = System.Drawing.Color.FromKnownColor(KnownColor.ControlDark);

            return color;
        }

        private void cogJobResultHistoryCollectionEdit1_SelectedJobIndexChanged(object sender, System.EventArgs e)
        {
            if (cogJobResultHistoryCollectionEdit1.Subject != null && cogJobResultHistoryCollectionEdit1.SelectedIndex >= 0 &&
              cogJobResultHistoryCollectionEdit1.SelectedIndex != mSelectedJob)
            {
                int oldJob = mSelectedJob;
                mSelectedJob = cogJobResultHistoryCollectionEdit1.SelectedIndex;

                UpdateGUIForSelectedJobChange(oldJob);
                UpdateGUIForSelectedJob(true);
            }
        }

        private void cogJobResultHistory_CurrentItemChanged(object sender, System.EventArgs e)
        {
            bool newResultForSelectedJob = false;

            int jobIndex = FindResultHistoryIndex(sender);
            if (jobIndex < 0)
                return;

            if (jobIndex == mSelectedJob)
                newResultForSelectedJob = true;

            UpdateGUIForJob(jobIndex);

            // if there is a new result for the selected job, update the gui now
            if (newResultForSelectedJob)
                UpdateGUIForSelectedJob(false);
        }
        #endregion

        #region Live Display
        private void StartLiveDisplay(int jobNumber)
        {
            CogJob j = mJM.Job(jobNumber);
            if (j.State == CogJobStateConstants.Stopped)
                j.RunContinuous();
        }

        private void StopLiveDisplay(int jobNumber)
        {
            CogJob j = mJM.Job(jobNumber);
            if (j.State == CogJobStateConstants.RunningContinuous)
                j.Stop();
        }

        private void checkBox_LiveDisplay_CheckedChanged(object sender, System.EventArgs e)
        {
            if (checkBox_LiveDisplay.Checked == true)
            {
                // clear stats
                ResetStatisticsForAllJobs();
                for (int i = 0; i < mJM.JobCount; i++)
                    UpdateStatisticsForJob(i);

                // enable live
                mCurrentRunState = RunState.RunningLive;
                SetResultBarCurrent();
                SelectedUcJob.cogRecordsDisplay1.Subject = null;

                // save old modes & setup jobs for live
                SetupForLive();

                try
                {
                    StartLiveDisplay(mSelectedJob);
                }
                catch (Cognex.VisionPro.Exceptions.CogException ex)
                {
                    RestoreJobStates();
                    mCurrentRunState = RunState.Stopped;
                    SetResultBarCurrent();
                    MessageBoxE.Show(this, ResourceUtility.GetString("RtUnexpectedErrorQB") + ex.Message,
                      mApplicationName);

                    // need to set the checkbox back to unchecked - note that this causes a recurse call
                    // to occur, so the "checked == false" handling below needs to be able to handle this
                    checkBox_LiveDisplay.Checked = false;
                }
            }
            else
            {
                // stop live
                StopLiveDisplay(mSelectedJob);
            }

            UpdateControlsEnabled();
        }

        private void SetupForLive()
        {
            mJobData = new JobData[mJM.JobCount];
            for (int i = 0; i < mJobData.Length; ++i)
            {
                mJobData[i] = new JobData();

                CogJob j = mJM.Job(i);
                mJobData[i].lastRunMode = j.RunMode;
                mJobData[i].lastStartMode = j.StartMode;

                j.StartMode = CogJobStartModeConstants.IssuedAfterAcquisitionCompletes;
                j.RunMode = CogJobRunModeConstants.ImageProcessingOnly;
                j.ImageAvailable += new CogJob.CogImageAvailableEventHandler(mJM_ImageAvailable);
                j.Stopped += new CogJob.CogJobStoppedEventHandler(mJM_JobStopped);
            }
        }

        private void RestoreJobStates()
        {
            // restore all jobs start & run modes
            for (int idx = 0; idx < mJM.JobCount; ++idx)
            {
                CogJob j = mJM.Job(idx);
                j.StartMode = mJobData[idx].lastStartMode;
                j.RunMode = mJobData[idx].lastRunMode;
                j.ImageAvailable -= new CogJob.CogImageAvailableEventHandler(mJM_ImageAvailable);
                j.Stopped -= new CogJob.CogJobStoppedEventHandler(mJM_JobStopped);
            }

            // done with jobdata
            mJobData = null;
        }
        #endregion

        #region Login


        private bool PromptForAccessLevelChange(AccessLevel newAccessLevel)
        {
            // not using passwords, or going "down" in access level - always allowed
            if (!mUsePasswords || newAccessLevel <= CurrentAccessLevel)
                return true;

            string expected = mCurrentPasswordFile.GetPasswordForAccessLevel(newAccessLevel);
            if (expected != "")
            {
                // get password from user
                FormPasswordPrompt prompt = new FormPasswordPrompt();
                prompt.Text = ResourceUtility.FormatString("RtEnterPassword", newAccessLevel.ToString());
                DialogResult result = prompt.ShowDialog(this);
                if (result != DialogResult.OK)
                    return false;
                if (prompt.Password != expected)
                {
                    MessageBoxE.Show(this, ResourceUtility.GetString("RtInvalidPassword2"), ResourceUtility.GetString("RtInvalidPassword"));
                    return false;
                }
            }

            return true;
        }
        #endregion

        #region Other buttons (config, save settings, about)
        private void button_Configuration_Click(object sender, System.EventArgs e)
        {
            FormConfig frmConfigSelect = new FormConfig(mQuickBuildAccess, mUsePasswords);
            frmConfigSelect.ShowDialog(this);

            switch (frmConfigSelect.Result)
            {
                case FormConfigResult.None:
                    break;

                case FormConfigResult.QuickBuild:
                    // detach from job manager before displaying edit control
                    AttachToJobManager(false);

                    // put up a new dialog containing QB editor
                    FormQB frm = new FormQB(mJM);
                    frm.ShowDialog(this);
                    frm.Dispose();

                    // prompt for save of vpp file
                    string vpp = mLoadedVppFilename;
                    string quotedvpp = "\"" + vpp + "\"";
                    string saveButtonName = ResourceUtility.GetString("RtSaveSettingsButton");
                    string quotedSaveButtonName = "\"" + saveButtonName + "\"";
                    string promptStr = ResourceUtility.FormatString("RtSaveSettingsTextAfterConfig", quotedvpp, quotedSaveButtonName);
                    PromptToSaveSettings(promptStr);

                    // re-attach
                    AttachToJobManager(true);
                    break;

                case FormConfigResult.SetPasswords:
                    FormSetPasswords frmPasswords = new FormSetPasswords(mCurrentPasswordFile);
                    frmPasswords.ShowDialog(this);
                    break;

                case FormConfigResult.AppOptions:
                    FormAppOptions frmOptions = new FormAppOptions(this);
                    frmOptions.EnableDisplay = mCurrentOptionsFile.EnableImageDisplay;
                    frmOptions.EnableIOAtStartup = mCurrentOptionsFile.EnableIOAtStartup;
                    frmOptions.EnableIO = mJM.IOEnable;
                    DialogResult result = frmOptions.ShowDialog(this);
                    if (result == DialogResult.OK)
                    {
                        mCurrentOptionsFile.EnableImageDisplay = frmOptions.EnableDisplay;
                        mCurrentOptionsFile.EnableIOAtStartup = frmOptions.EnableIOAtStartup;
                        mCurrentOptionsFile.Write();

                        // handle IO state change
                        if (frmOptions.EnableIO != mJM.IOEnable)
                        {
                            try
                            {
                                mJM.IOEnable = frmOptions.EnableIO;
                            }
                            catch (Cognex.VisionPro.Exceptions.CogException ex)
                            {
                                MessageBoxE.Show(this, ResourceUtility.GetString("RtUnexpectedErrorQB") + ex.Message,
                                                mApplicationName);
                            }
                        }
                    }
                    break;
            }
        }

        public void PromptToSaveSettings(string promptString)
        {
            DialogResult result = MessageBoxE.Show(this, promptString, ResourceUtility.GetString("RtSaveSettingsTitle"),
              MessageBoxButtons.YesNo);
            if (result == DialogResult.Yes || result == DialogResult.OK)
            {
                if (mJM.JobsRunningState != CogJobsRunningStateConstants.None)
                {
                    MessageBoxE.Show(this, ResourceUtility.GetString("RtErrorSavingVpp_Running"), mApplicationName);
                    return;
                }

                string vpp = mLoadedVppFilename;
                try
                {
                    bool wasAttached = mAttached;
                    if (wasAttached)
                        AttachToJobManager(false);

                    // save the QuickBuild project file
                    try
                    {
                        Utility.FlushAllQueues(mJM);
                        CogSerializer.SaveObjectToFile(mJM, vpp);
                        log.Info($"编辑保存VPP文件“{vpp}”");
                    }
                    catch (Exception ex)
                    {
                        MessageBoxE.Show(this, ResourceUtility.FormatString("RtErrorSavingVpp", vpp) + ex.Message,
                          mApplicationName);
                    }

                    if (wasAttached)
                        AttachToJobManager(true);
                }
                catch (Exception ex)
                {
                    MessageBoxE.Show(this, ResourceUtility.FormatString("RtErrorSavingVpp", vpp) + ex.Message,
                      mApplicationName);
                }
            }
        }

        private void PromptToSaveSettings_NOMessage(string promptString)
        {

            if (mJM.JobsRunningState != CogJobsRunningStateConstants.None)
            {
                MessageBoxE.Show(this, ResourceUtility.GetString("RtErrorSavingVpp_Running"), mApplicationName);
                return;
            }

            string vpp = mLoadedVppFilename;
            try
            {
                bool wasAttached = mAttached;
                if (wasAttached)
                    AttachToJobManager(false);

                // save the QuickBuild project file
                try
                {
                    Utility.FlushAllQueues(mJM);
                    CogSerializer.SaveObjectToFile(mJM, vpp);
                }
                catch (Exception ex)
                {
                    MessageBoxE.Show(this, ResourceUtility.FormatString("RtErrorSavingVpp", vpp) + ex.Message,
                      mApplicationName);
                }

                if (wasAttached)
                    AttachToJobManager(true);
            }
            catch (Exception ex)
            {
                MessageBoxE.Show(this, ResourceUtility.FormatString("RtErrorSavingVpp", vpp) + ex.Message,
                  mApplicationName);
            }
        }


        private void button_SaveSettings_Click(object sender, System.EventArgs e)
        {
            string vpp = mLoadedVppFilename;
            string quotedvpp = "\"" + vpp + "\"";
            string promptStr = ResourceUtility.FormatString("RtSaveSettingsText", quotedvpp);

            PromptToSaveSettings(promptStr);
        }

        private void button_About_Click(object sender, System.EventArgs e)
        {
            // resolve the aboutbox text filename
            string aboutFilename = Utility.ResolveAssociatedFilename(mVppFilename, "about.txt");

            FormAbout about = new FormAbout(aboutFilename, this);
            about.Text = ResourceUtility.FormatString("RtAboutTitle", this.Text);
            about.ShowDialog(this);
        }
        #endregion

        #region GUI update support
        /*
         * The GUI update goals of this application are as follows:
         * 
         * 1.  We would like most, if not all, GUI updates to occur in the context of a
         *     QuickBuild job thread.  This helps to avoid the case where GUI updates
         *     occur in a separate thread, causing job threads to block momentarily at
         *     arbitrary times (for some time critical applications, this behavior is
         *     not acceptable).
         * 
         * 2.  We would like to avoid repainting the GUI every time a new job result is
         *     available, as this rate is application dependent and can occur hundreds of
         *     times per second.  Repainting at a very high rate wastes CPU cycles.
         * 
         * The GUI update strategy of this application is as follows:
         * 
         * 1.  Two flags track the status of GUI updates:
         *     mHaveUnpaintedResults - tracks when new results are available that have
         *       not yet been painted.  This flag is set every time a new user result
         *       is generated by the application.
         *     mMinimumGuiUpdateNeeded - indicates that painting is now required - we've
         *       passed the minimum amount of time between paints and new results are
         *       available.
         * 
         * 2.  A timer (mMinimumGuiPeriodTimer) is set to go off every 50 ms.  If the
         *     handler for this timer determines the we have unpainted results, then it
         *     sets the mMinimumGuiUpdateNeeded flag.
         * 
         * 3.  Every time a new user result is generated, the mMinimumGuiUpdateNeeded
         *     flag is checked (in the "UserResultAvailable" event handler).  If an update
         *     is needed, it is performed immediately, which causes it to occur in the context
         *     of a job thread.
         * 
         * 4.  A second timer (mMaximumGuiPeriodTimer) is set to go off every 500 ms.  This
         *     timer handles the case where user results are generated relatively slowly, or
         *     they stop being generated for some reason (triggers stop occurring, etc).  The
         *     event handler for this timer performs a paint.  In this case, the paint is not
         *     performed in a job thread.
         * 
         * 5.  The mMaximumGuiPeriodTimer is reset every time a paint occurs, such that its
         *     handler is only called if a paint has not happened in the last 500 ms.
         */

        private void mMaximumGuiPeriodTimer_Elapsed(object obj)
        {
            UpdateGui(null, null);
        }

        private void UpdateGui(object sender, System.EventArgs e)
        {
            try
            {
                if (mIsClosing)
                {
                    return;
                }
                if (this.InvokeRequired)
                {
                    // Call this same function on the GUI thread.
                    // Invoke currently has a bug, and it is fixed in .NET2.0
                    IAsyncResult async = BeginInvoke(new System.EventHandler(UpdateGui), new object[] { sender, e });
                    while (!mIsClosing && !async.IsCompleted && !async.AsyncWaitHandle.WaitOne(300, false)) ;

                    // if the VisionControl is closing, updating the GUI is not necessary any more, besides it
                    // might also cause deadlock
                    if (mIsClosing)
                    {
                        async.AsyncWaitHandle.Close();
                    }
                    else
                    {
                        EndInvoke(async);
                    }

                    return;
                }

                ResetMaximumGuiUpdateTimer();
                ResetMinimumGuiUpdateTimer();
                if (mCurrentRunState != RunState.Stopped)
                {
                    for (int i = 0; i < mJM.JobCount; ++i)
                    {
                        if (mJM.Job(i).State != CogJobStateConstants.Stopped)
                            SetElapseText(i);
                    }
                    SetElapseText(null);
                    //tbElapse.Text += ".000";
                }
                // update everything we can on the gui from here

                lock (mMinimumGuiPeriodTimer)
                {
                    mHaveUnpaintedResults = false;
                }

                for (int i = 0; i < mHistoryCollection.Count; ++i)
                {
                    CogJobResultHistoryGated hist = (CogJobResultHistoryGated)mHistoryCollection[i];
                    hist.SnapshotNow();
                }

                UpdateStatisticsForJob(mSelectedJob);
                UpdateOnlineStatus();

                //this.Update();

                lock (mMinimumGuiPeriodTimer)
                {
                    mMinimumGuiUpdateNeeded = false;
                }
            }
            catch { }
        }

        private void ResetMaximumGuiUpdateTimer()
        {
            mMaximumGuiPeriodTimer?.Change(MaximumPeriodMs, MaximumPeriodMs);
        }
        private void ResetMinimumGuiUpdateTimer()
        {
            mMinimumGuiPeriodTimer?.Change(MinimumPeriodMs, MinimumPeriodMs);
        }

        private void UpdateGuiIfNeeded()
        {
            // this function is called every time a new user result is available.  it performs
            // a paint if the minimum amount of time between paints has elapsed.
            bool updateNeeded;
            lock (mMinimumGuiPeriodTimer)
            {
                updateNeeded = mMinimumGuiUpdateNeeded;
            }

            if (updateNeeded)
                UpdateGui(null, null);
        }

        private void mMinimumGuiPeriodTimer_Elapsed(object obj)
        {
            // the minimum amount of time between paints has elapsed.  if we have any unpainted
            // results, then indicate that the next generated user result should perform a paint.
            bool updateNow = false;
            if (obj == null)
                return;
            lock (mMinimumGuiPeriodTimer)
            {
                if (!mMinimumGuiUpdateNeeded && !mHaveUnpaintedResults)
                    ResetMaximumGuiUpdateTimer();
                else
                {
                    updateNow = true;
                    mMinimumGuiUpdateNeeded = true;
                }
            }

            if (updateNow && mCurrentRunState == RunState.Stopped)
                UpdateGui(null, null);
        }

        private void cogJobResultHistory_RequestImmediateUpdate(object sender, System.EventArgs e)
        {
            // called when the user interacts with the scrolling history display (selects a different
            // queue or result record for viewing)
            lock (mMinimumGuiPeriodTimer)
            {
                mMinimumGuiUpdateNeeded = true;
            }
        }
        #endregion

        #region Statistics
        private void ResetStatisticsForAllJobs()
        {
            for (int i = 0; i < mJM.JobCount; i++)
                ResetStatisticsForJob(i);
        }

        private void ResetStatisticsForJob(int i)
        {
            mJM.Job(i).ResetAllStatistics();
            mJM.Job(i).RestartThroughputCalculation();
        }

        private void button_ResetStatisticsForAllJobs_Click(object sender, System.EventArgs e)
        {
            ResetStatisticsForAllJobs();
            lock (mMinimumGuiPeriodTimer)
            {
                mMinimumGuiUpdateNeeded = true;
            }
        }

        private void button_ResetStatistics_Click(object sender, System.EventArgs e)
        {
            ResetStatisticsForJob(mSelectedJob);
            lock (mMinimumGuiPeriodTimer)
            {
                mMinimumGuiUpdateNeeded = true;
            }
        }

        private void UpdateStatisticsForJob(int i)
        {
            // don't update statistics when showing live video
            bool runningLive = mCurrentRunState == RunState.RunningLive;
            if (runningLive)
                return;

            CogJob j = mJM.Job(i);
            //textBox_JobN_TotalIterations.Text = j.TotalJobIterations.ToString();
            //textBox_JobN_TotalAccept.Text = j.TotalVisionToolAccepts.ToString();
            string percentStr = "";
            if (j.TotalJobIterations > 0)
            {
                double p = j.TotalVisionToolAccepts * 100.0 / j.TotalJobIterations;
                percentStr = p.ToString("0.0");
            }

            /* textBox_JobN_TotalAccept_Percent.Text = percentStr;
              textBox_JobN_TotalReject.Text = j.TotalVisionToolRejects.ToString();
              textBox_JobN_TotalWarning.Text = j.TotalVisionToolWarnings.ToString();
              textBox_JobN_TotalError.Text = j.TotalVisionToolErrors.ToString();

              textBox_JobN_TotalAcquisitions.Text = j.TotalAcquisitions.ToString();
              textBox_JobN_TotalAcquisitionErrors.Text = j.TotalAcquisitionErrors.ToString();
              textBox_JobN_TotalAcquisitionOverruns.Text = j.TotalAcquisitionOverruns.ToString();

              if (j.TotalJobThroughputMax != 0)
              {
                  textBox_JobN_Throughput.Text = j.TotalJobThroughput.ToString("0.000");
                  textBox_JobN_MinThroughput.Text = j.TotalJobThroughputMin.ToString("0.000");
                  textBox_JobN_MaxThroughput.Text = j.TotalJobThroughputMax.ToString("0.000");
              }
              else
              {
                  string waiting = ResourceUtility.GetString("RtStatsWaiting");
                  textBox_JobN_Throughput.Text = waiting;
                  textBox_JobN_MinThroughput.Text = waiting;
                  textBox_JobN_MaxThroughput.Text = waiting;
              }*/

            #region 获取当前作业组件中的所有非Output的输出值
            CogToolGroup ctg = (CogToolGroup)j.VisionTool;
            List<CogResultsAnalysisTool> list = new List<CogResultsAnalysisTool>();
            //获取当前job中的所有CogResultsAnalysisTool控件
            for (int n = 0; n < ctg.Tools.Count; n++)
            {
                if (ctg.Tools[n] is CogResultsAnalysisTool)
                {
                    list.Add((CogResultsAnalysisTool)ctg.Tools[n]);
                }
            }

            List<CogResults> listData = new List<CogResults>();
            //取出控件中的值并存入Dic
            foreach (CogResultsAnalysisTool cogResults in list)
            {
                if (cogResults.Result == null)
                {
                    break;
                }
                foreach (string key in cogResults.Result.EvaluatedExpressions.Keys)
                {
                    if (key != "Output")
                    {
                        CogResults data = new CogResults();

                        data.cogResultName = cogResults.Name;
                        data.key = key;
                        data.value = cogResults.Result.EvaluatedExpressions[key].Value.ToString();
                        listData.Add(data);
                    }
                }
            }
            // this.dataGridView1.DataSource = listData;          



            #endregion
        }
        #endregion
        public void OpenVpp(string file)
        {
            setApplication(file);

            //for (int i = 0; i < tabControl_JobTabs.TabCount; i++)
            //    tabControl_JobTabs.TabPages[i].Dispose();
            //tabControl_JobTabs.TabPages.Clear();
            VisionControl_Load(null, EventArgs.Empty);

            string vpp = mLoadedVppFilename;
            string quotedvpp = "\"" + vpp + "\"";
            string promptStr = ResourceUtility.FormatString("RtSaveSettingsText", quotedvpp);
            if (JobManager != null)
                PromptToSaveSettings_NOMessage(promptStr);
            ProjectOpened?.Invoke(file);
        }
        private void button_Chose_Click(object sender, EventArgs e)
        {
        }
        bool CheckJob()
        {
            if (JobManager == null)
            {
                MessageBoxE.Show(this, "CobJob 未初始化。" + jobError, "错误");
                return false;
            }
            return true;
        }

        private void uiNavBar1_TabIndexChanged(object sender, EventArgs e)
        {

        }

        private void uiNavBar1_MenuItemClick(string itemText, int menuIndex, int pageIndex)
        {
            switch (itemText)
            {

                case "TCP/IP":
                    this.uiTabControl1.SelectedTab = tpTcp;
                    break;
                case "串口":
                    uiTabControl1.SelectedTab = tpSerPort;
                    break;
                default:
                    uiTabControl1.SelectedIndex = 0;
                    break;
            }

        }

        private void uiNavBar1_NodeMouseClick(TreeNode node, int menuIndex, int pageIndex)
        {

        }
    }


    #region Internal helper classes
    internal class JobData
    {
        public CogJobStartModeConstants lastStartMode = CogJobStartModeConstants.IssuedAfterAcquisitionCompletes;
        public CogJobRunModeConstants lastRunMode = CogJobRunModeConstants.AcquisitionAndImageProcessing;
    }

    // helper class to store localized name and enum value, for use in combo box display
    internal class AccessLevel_Localized
    {
        public AccessLevel_Localized(AccessLevel v, string t)
        {
            val = v;
            text = t;
        }

        public override string ToString()
        {
            // return the localized name
            return text;
        }

        public AccessLevel val;
        public string text;
    }
    #endregion

    #region UserResultAvailable event support
    public class VisionControlUserResultAvailableEventArgs
    {
        public int JobIndex;
        public ICogRecord Result;

        public VisionControlUserResultAvailableEventArgs(int jobIndex, ICogRecord result)
        {
            JobIndex = jobIndex;
            Result = result;
        }
    }

    public delegate void VisionControlUserResultAvailableEventHandler(object sender, VisionControlUserResultAvailableEventArgs e);
    #endregion

    #region defined CogResults
    public class CogResults
    {
        public string cogResultName { get; set; }
        public string key { get; set; }
        public string value { get; set; }
    }
    #endregion
}
